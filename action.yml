name: 'html-reporter-github-pages'
description: 'GitHub Pages HTML Test Results History - Static Website'
author: 'Pavan Mudigonda'
branding:
  icon: 'layout'
  color: 'green'
inputs:
  token:
    description: 'default Github token'
    required: false
    default: ${{ github.token }}
  test_results:
    description: 'test result data dir. If its Allure Results Provide RAW Results to generate Allure Report'
    default: 'test-results'
    required: false
  gh_pages:
    description: 'Folder with gh-pages branch'
    required: false
    default: 'gh-pages'
  results_history:
    description: 'Folder for results history'
    required: false
    default: 'results-history'
  tool_name:
    description: 'Tool name used as a subfolder in the report directory hierarchy'
    required: false
    default: ''  
  workflow_name:
    description: 'Workflow name used as a subfolder in the report directory hierarchy'
    required: false
    default: '${{ github.workflow }}'
  env:
    description: 'Environment'
    required: false
  subfolder:
    description: 'subfolder'
    required: false
    default: 'docs'
  keep_reports:
    description: 'Keep X last reports'
    required: false
    default: '20'
  github_run_num:
    description: 'GitHub Actions build number'
    required: false
    default: ${{ github.run_number }}
  github_run_id:
    description: 'GitHub Actions run id'
    required: false
    default: ${{ github.run_id }}
  github_repo:
    description: 'GitHub repository'
    required: false
    default: ${{ github.repository }}
  report_url:
    description: 'Use a custom URL instead of *.github.io'
    required: false
    default: '' 
  external_repository:
    description: 'External GitHub repository'
    required: false 
  order:
    description: 'Order of Folders, ascending or descending'
    required: false
    default: 'descending'
  allure_report_generate_flag:
    description: 'To Generate Allure Report using this Action'
    required: false
    default: 'false'
  use_actions_summary:
    description: 'To write outputs to actions summary'
    required: false
    default: 'true'
  force_orphan:
    description: 'Create a fresh orphan commit on each deploy, eliminating git history to keep the gh-pages branch small. Recommended for large/frequent deployments.'
    required: false
    default: 'true'
outputs:
  url:
    description: 'GH Page URL'
    value: ${{ steps.gh_page.outputs.GITHUB_PAGES_WEBSITE_URL }}
  latest_result_url:
    description: 'Latest Test Result GH Pages URL'
    value: ${{ steps.gh_page.outputs.LATEST_RUN_GH_PAGES_URL }}

runs:
  using: 'composite'    
  steps:
    - name: Validate inputs
      shell: bash
      run: |
        set -e
        echo "::group::Validating action inputs"
        
        # Validate keep_reports is a positive integer
        if ! [[ "${{ inputs.keep_reports }}" =~ ^[0-9]+$ ]]; then
          echo "::error::keep_reports must be a positive integer, got: ${{ inputs.keep_reports }}"
          exit 1
        fi
        
        # Validate order parameter
        if [[ "${{ inputs.order }}" != "ascending" && "${{ inputs.order }}" != "descending" ]]; then
          echo "::error::order must be 'ascending' or 'descending', got: ${{ inputs.order }}"
          exit 1
        fi
        
        # Validate test_results directory exists
        if [ ! -d "${{ inputs.test_results }}" ]; then
          echo "::error::test_results directory not found: ${{ inputs.test_results }}"
          exit 1
        fi
        
        # Validate subfolder doesn't contain dangerous paths
        if [[ "${{ inputs.subfolder }}" == *..* ]]; then
          echo "::error::subfolder cannot contain '..' (parent directory references)"
          exit 1
        fi
        
        if [[ "${{ inputs.subfolder }}" == /* ]]; then
          echo "::error::subfolder cannot be an absolute path (cannot start with '/')"
          exit 1
        fi
        
        # Validate allure_report_generate_flag is a boolean
        if [[ "${{ inputs.allure_report_generate_flag }}" != "true" && "${{ inputs.allure_report_generate_flag }}" != "false" ]]; then
          echo "::error::allure_report_generate_flag must be 'true' or 'false', got: ${{ inputs.allure_report_generate_flag }}"
          exit 1
        fi
        
        # Validate use_actions_summary is a boolean
        if [[ "${{ inputs.use_actions_summary }}" != "true" && "${{ inputs.use_actions_summary }}" != "false" ]]; then
          echo "::error::use_actions_summary must be 'true' or 'false', got: ${{ inputs.use_actions_summary }}"
          exit 1
        fi
        
        # Warn about external_repository usage
        if [[ -n "${{ inputs.external_repository }}" ]]; then
          echo "::warning::Using external_repository requires a Personal Access Token (PAT) with 'repo' scope."
          echo '::warning::Make sure you provide: token: ${{ secrets.GH_PAT }} in your workflow file'
          echo "::warning::The default GITHUB_TOKEN cannot push to external repositories."
        fi
        
        echo "✅ All input validations passed"
        echo "::endgroup::"
    
    - name: Install GH CLI
      uses: sersoft-gmbh/setup-gh-cli-action@v2.0.1
      with:
        version: stable
        github-token: ${{ inputs.token }}

    - name: Java Install for Allure
      if: ${{ inputs.allure_report_generate_flag == 'true' }}
      uses: actions/setup-java@v4.2.1
      with:
        distribution: 'corretto'
        java-version: '17'

    - name: Create a new gh pages branch if it doesn't exist - same repo
      if: ${{ inputs.external_repository == '' }}
      shell: bash
      env:
        GIT_USER_EMAIL: actions@github.com
        GIT_USER_NAME: GitHub Actions
        GITHUB_TOKEN: ${{ inputs.token }}
      run: |
        set -e
        CURRENT_BRANCH=$(git branch --show-current)
        # Fallback to SHA if in detached HEAD state (common in GitHub Actions)
        if [[ -z "$CURRENT_BRANCH" ]]; then
          CURRENT_REF=$(git rev-parse HEAD)
          echo "In detached HEAD state, will restore to commit: $CURRENT_REF"
        else
          CURRENT_REF="$CURRENT_BRANCH"
          echo "Current branch: $CURRENT_BRANCH"
        fi
        STASHED=false
        if [[ -n $(git status -s) ]]; then
          git stash push --keep-index --include-untracked || true
          STASHED=true
        fi;

        # Check if the remote branch exists (use token for private repo support)
        if git ls-remote --exit-code --heads "https://x-access-token:${GITHUB_TOKEN}@github.com/${{ github.repository }}.git" "${{ inputs.gh_pages }}"; then
          echo "REMOTE BRANCH EXISTS"
        else
          git config --local user.email "$GIT_USER_EMAIL"
          git config --local user.name "$GIT_USER_NAME"
          git switch --orphan "${{ inputs.gh_pages }}"
          git add .
          git commit --allow-empty -m "Initial commit on orphan branch"
          git config --global pull.rebase true
          # Configure git to use token for authentication
          git remote set-url origin "https://x-access-token:${GITHUB_TOKEN}@github.com/${{ github.repository }}.git"
          git push -u origin "${{ inputs.gh_pages }}"
        fi;

        # Switch back to the original branch or commit
        git checkout "$CURRENT_REF"

        # Restore the stash if there was one
        if [[ "$STASHED" == true ]]; then
          if git stash list | grep -q "WIP"; then
            git stash pop || true
          else
            echo "No stash entries found."
          fi
        fi;

    - name: delete github pages folder if its present
      shell: bash
      run: |
        # Check if the folder exists
        if [ -d "${{ inputs.gh_pages }}" ]; then
          echo "Folder exists. Deleting..."
          rm -rf "${{ inputs.gh_pages }}"
          echo "Folder deleted."
        else
          echo "Folder does not exist."
        fi;
        
    - name: Get test results history
      if: ${{ inputs.external_repository == '' }}
      uses: actions/checkout@v5.0.0
      continue-on-error: true
      with:
        ref: ${{ inputs.gh_pages }}
        path: ${{ inputs.gh_pages }}
        persist-credentials: false

    - id: external-repo
      shell: bash
      if: ${{ inputs.external_repository != '' }} 
      env:
        GH_TOKEN: ${{ inputs.token }}
      run: |
        if [[ -z "${{ inputs.gh_pages }}" ]]
        then
          if [[ "${{ inputs.external_repository }}" != "${{ github.repository }}" ]]
          then
            USING="main"
          else
            USING="$(gh api /repos/${{ inputs.external_repository }}/commits/${{ github.sha }}/branches-where-head --jq '.[0].name' 2>/dev/null || echo "main")"
            # Handle null or empty response
            if [[ "$USING" == "null" || -z "$USING" ]]; then
              USING="main"
            fi
          fi
          echo "::notice::Checkout: ${{ inputs.external_repository }} using ${USING}"
          echo "ref-exists=true" >> $GITHUB_OUTPUT
        else
          if git ls-remote --heads --quiet --exit-code "https://${{ inputs.token }}@github.com/${{ inputs.external_repository }}.git" ${{ inputs.gh_pages }}
          then
            echo "::notice::Checkout: ${{ inputs.external_repository }} using ${{ inputs.gh_pages }}"
            echo "ref-exists=true" >> $GITHUB_OUTPUT
          else
            USING="$(gh api /repos/${{ inputs.external_repository }} --jq '.default_branch' 2>/dev/null || echo "main")"
            # Handle null or empty response
            if [[ "$USING" == "null" || -z "$USING" ]]; then
              USING="main"
            fi
            echo "::notice::Checkout: ${{ inputs.external_repository }} does not have ref ${{ inputs.gh_pages }} (fallback to ${USING})"
            echo "ref-exists=false" >> $GITHUB_OUTPUT
            echo "default-branch=${USING}" >> $GITHUB_OUTPUT
          fi
        fi

    - if: ${{ ( steps.external-repo.outputs.ref-exists == 'true' ) && ( inputs.external_repository != '' ) }}
      uses: actions/checkout@v5.0.0
      with:
        path: ${{ inputs.gh_pages }}
        repository: ${{ inputs.external_repository }}
        ref: ${{ inputs.gh_pages }}
        token: ${{ inputs.token }}
        persist-credentials: false

    - if: ${{ ( steps.external-repo.outputs.ref-exists == 'false' ) && ( inputs.external_repository != '' ) }}
      uses: actions/checkout@v5.0.0
      with:
        path: ${{ inputs.gh_pages }}
        repository: ${{ inputs.external_repository }}
        ref: ${{ steps.external-repo.outputs.default-branch }}
        token: ${{ inputs.token }}
        persist-credentials: false

    - name: Create a new gh pages branch if it doesn't exist - external repo
      shell: bash
      if: ${{ ( inputs.external_repository != '' ) && ( steps.external-repo.outputs.ref-exists == 'false' ) }}
      env:
        GIT_USER_EMAIL: "actions@github.com"
        GIT_USER_NAME: "GitHub Actions"
        GITHUB_TOKEN: ${{ inputs.token }}
      run: |
        echo "Creating new gh-pages branch for external repo"
        mkdir -p "${{ inputs.gh_pages }}"
        cd "${{ inputs.gh_pages }}"
        git config --local user.email "$GIT_USER_EMAIL"
        git config --local user.name "$GIT_USER_NAME"
        git switch --orphan "${{ inputs.gh_pages }}"
        git add .
        git commit --allow-empty -m "Initial commit on orphan branch"
        git config --global pull.rebase true
        # Configure git to use token for authentication
        git remote set-url origin "https://x-access-token:${GITHUB_TOKEN}@github.com/${{ inputs.external_repository }}.git"
        git push -u origin "${{ inputs.gh_pages }}"

    - name: Create Test Results History GitHub Actions Run ID wise
      id: gh_page
      shell: bash
      env: 
        ALLURE_FLAG: "${{ inputs.allure_report_generate_flag }}"      
        ENV: "${{ inputs.env }}"
        TOKEN: "${{ inputs.token }}"
        GH_PAGES: "${{ inputs.gh_pages }}"
        SUBFOLDER: "${{ inputs.subfolder }}"
        KEEP_REPORTS: "${{ inputs.keep_reports }}"
        GITHUB_RUN_ID: "${{ inputs.github_run_id }}"
        REPO: "${{ inputs.github_repo }}"
        GITHUB_REPOSITORY: "${{ github.repository }}"
        REPORT_URL: "${{ inputs.report_url }}"
        EXTERNAL_REPO: "${{ inputs.external_repository }}"
        RUNNER_OS: "${{ runner.os }}"
        GITHUB_RUN_NUM: "${{ inputs.github_run_num }}"
        TOOL_NAME: "${{ inputs.tool_name }}"
        ORDER: "${{ inputs.order }}"
        GH_TOKEN: "${{ inputs.token }}"
        TEST_RESULTS: "${{ inputs.test_results }}"
        USE_ACTIONS_SUMMARY: "${{ inputs.use_actions_summary }}"
        WORKFLOW_NAME: "${{ inputs.workflow_name }}"
      run: |
        set -e
        GH_PAGES_ACTION_HOME="$PWD"
        # Transform workflow name: replace spaces with hyphens
        WORKFLOW_NAME=$(echo "${WORKFLOW_NAME}" | tr " " "-")
        #--------------------------------------------------------
        mkdir -p "${GH_PAGES}"
        cd "${GH_PAGES}"
        if [[ "${SUBFOLDER}" != "" ]]; then
          mkdir -p "${SUBFOLDER}"
        fi;
        cd "${GH_PAGES_ACTION_HOME}"
        # Set variables
        if [[ "${ALLURE_FLAG}" == 'true' ]]; then
          ALLURE_REPORT="allure-report"
        fi;
        #-------------------------------------------------------------------
        # Use single index generator script with order parameter
        INDEX_SCRIPT_PATH=${{ github.action_path }}/scripts/index-html-generator.py
        #-------------------------------------------------------------------
        # Check if its external repo push
        if [[ ${EXTERNAL_REPO} != '' ]]; then
          REPOSITORY_OWNER_SLASH_NAME=${EXTERNAL_REPO}
        elif [[ ${EXTERNAL_REPO} == '' ]]; then
          REPOSITORY_OWNER_SLASH_NAME=${GITHUB_REPOSITORY}
        fi;
        #-------------------------------------------------------------------
        delete_folders_func () {
          # Count only numeric run directories (not index.html, last-history, etc.)
          COUNT=$(find . -maxdepth 1 -type d -regex '.*/[0-9]+' 2>/dev/null | wc -l)
          echo "count numeric run folders in results-history: ${COUNT}"
          echo "keep reports count ${KEEP_REPORTS}"
          if (( COUNT >= KEEP_REPORTS )); then
            echo "remove old reports"
            REMOVE_COUNT=$(( COUNT - KEEP_REPORTS + 1 ))
            find . -maxdepth 1 -type d -regex '.*/[0-9]+' -print0 | sort -zn | head -zn "${REMOVE_COUNT}" | xargs -0 rm -rv
            if [ -f index.html ]; then
              echo "remove index.html"
              rm -rv index.html
            fi;
            if [ -d last-history ]; then
              echo "remove last-history folder"
              rm -rv last-history
            fi;            
          fi;
        }
        #-------------------------------------------------------------------
        EXTERNAL_REPO_OWNER_SLASH_NAME=${EXTERNAL_REPO}
        EXTERNAL_REPO_NAME=${EXTERNAL_REPO_OWNER_SLASH_NAME##*/}
        if [[ "${EXTERNAL_REPO_NAME}" == '' ]]; 
        then
          GH_PAGES_API="/repos/${{ github.repository }}/pages"
        elif [[ "${EXTERNAL_REPO}" != '' ]]
        then
          GH_PAGES_API="/repos/${EXTERNAL_REPO}/pages"
        fi
        gh api -H "Accept: application/vnd.github+json" -H "X-GitHub-Api-Version: 2022-11-28" ${GH_PAGES_API} > gh-pages.json || true
        REPORT_URL=${REPORT_URL}
        #-------------------------------------------------------------------
        if [[ ${REPORT_URL} != '' ]]; then
            REPORT_URL="${REPORT_URL}"
            echo "Replacing github pages url. NEW url ${REPORT_URL}"
        else
            REPORT_URL=$(gh api -H "Accept: application/vnd.github+json" -H "X-GitHub-Api-Version: 2022-11-28" ${GH_PAGES_API} --jq '.html_url' 2>/dev/null | tr -d '"' | xargs || echo "")
            # Handle null, empty, or error responses (e.g. 403 when token lacks pages:read permission)
            if [[ "$REPORT_URL" == "null" || -z "$REPORT_URL" || "$REPORT_URL" == *"Resource not accessible"* || "$REPORT_URL" != http* ]]; then
              # Construct URL from repository name
              if [[ -n "${EXTERNAL_REPO}" ]]; then
                EXT_OWNER="${EXTERNAL_REPO%%/*}"
                EXT_NAME="${EXTERNAL_REPO##*/}"
                REPORT_URL="https://${EXT_OWNER}.github.io/${EXT_NAME}"
              else
                REPO_OWNER_NAME="${GITHUB_REPOSITORY%%/*}"
                REPO_BASE_NAME="${GITHUB_REPOSITORY##*/}"
                REPORT_URL="https://${REPO_OWNER_NAME}.github.io/${REPO_BASE_NAME}"
              fi
              echo "::notice::Could not fetch GitHub Pages URL via API (likely missing pages:read permission). Using constructed URL: ${REPORT_URL}"
              echo "::notice::To get the exact URL, add 'pages: write' to your workflow permissions block."
            fi
            REPORT_URL="${REPORT_URL%/}"
            echo $REPORT_URL
            echo REPORT_URL=$REPORT_URL >> $GITHUB_ENV
            if [[ "${USE_ACTIONS_SUMMARY}" != 'false' ]]; then
              echo "#### GitHub Pages HTML Reports" >> $GITHUB_STEP_SUMMARY
            fi;
            echo "REPORT_URL=${REPORT_URL}" >> $GITHUB_OUTPUT        
        fi;
        #-------------------------------------------------------------------
        # Save original GH_PAGES value before it gets modified
        GH_PAGES_BASE="${GH_PAGES}"
        # Identify where the current report should be copied to
        if [[ "${SUBFOLDER}" != "" ]]; then
          GH_PAGES="${GH_PAGES}/${SUBFOLDER}"
          mkdir -p "${GH_PAGES}"
        fi;
        if [[ "${TOOL_NAME}" != "" ]]; then
            GH_PAGES="${GH_PAGES}/${TOOL_NAME}"
            GITHUB_PAGES_WEBSITE_URL="${REPORT_URL}/${TOOL_NAME}"
            mkdir -p "${GH_PAGES}"
        else
            GITHUB_PAGES_WEBSITE_URL="${REPORT_URL}"
        fi;
        if [[ "${WORKFLOW_NAME}" != "" ]]; then
            GH_PAGES="${GH_PAGES}/${WORKFLOW_NAME}"
            GITHUB_PAGES_WEBSITE_URL="${GITHUB_PAGES_WEBSITE_URL}/${WORKFLOW_NAME}"
            mkdir -p "${GH_PAGES}"
        fi;
        if [[ "${ENV}" != "" ]]; then
            GH_PAGES="${GH_PAGES}/${ENV}"
            GITHUB_PAGES_WEBSITE_URL="${GITHUB_PAGES_WEBSITE_URL}/${ENV}"
            mkdir -p "${GH_PAGES}"
        fi;
        #-------------------------------------------------------------------        
        create_executor_json_func () {
          if [ ! -f ${TEST_RESULTS}/executor.json ]; then
            #echo "executor.json"
            echo '{"name":"GitHub Actions","type":"github","reportName":"Test Reporting",' > executor.json
            echo "\"url\":\"${GITHUB_PAGES_WEBSITE_URL}\"," >> executor.json # ???
            echo "\"reportUrl\":\"${GITHUB_PAGES_WEBSITE_URL}/${GITHUB_RUN_NUM}/\"," >> executor.json
            echo "\"buildUrl\":\"https://github.com/${{ github.repository }}/actions/runs/${GITHUB_RUN_ID}\"," >> executor.json
            echo "\"buildName\":\"GitHub Actions Run #${GITHUB_RUN_NUM}\",\"buildOrder\":\"${GITHUB_RUN_NUM}\"}" >> executor.json

            mv ./executor.json ${TEST_RESULTS}  
          fi
          if [ ! -f ${TEST_RESULTS}/environment.properties ]; then
            {
             echo URL=${GITHUB_PAGES_WEBSITE_URL}
             echo BUILD_URL=${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
             echo GIT_BRANCH=${{ github.head_ref || github.ref_name }}
             echo GIT_COMMIT_ID=${{ github.sha }}
             echo GIT_COMMIT_MESSAGE=$(git show -s --format=%s HEAD)
             echo GIT_COMMIT_AUTHOR_NAME=$(git show -s --format='%ae' HEAD)
             echo GIT_COMMIT_TIME=$(git show -s --format=%ci HEAD)
            } >> environment.properties

            mv ./environment.properties ${TEST_RESULTS}
          fi 
        }
        #-------------------------------------------------------------------
        copy_current_results_func () {
          mkdir -p "./${GH_PAGES}/${GITHUB_RUN_NUM}"
          # If we are not dealing with Allure Reports then copy the test results
          if [[ "${ALLURE_FLAG}" != 'true' ]]; then
            # Check if source directory exists and has content before copying
            if [ -d "${GH_PAGES_ACTION_HOME}/${TEST_RESULTS}" ] && [ "$(ls -A "${GH_PAGES_ACTION_HOME}/${TEST_RESULTS}" 2>/dev/null)" ]; then
              cp -r "${GH_PAGES_ACTION_HOME}/${TEST_RESULTS}"/. "./${GH_PAGES}/${GITHUB_RUN_NUM}"
              # If no index.html exists in run folder but HTML files are present, create a redirect index.html
              RUN_DEST="./${GH_PAGES}/${GITHUB_RUN_NUM}"
              if [ ! -f "${RUN_DEST}/index.html" ]; then
                HTML_FILE=$(find "${RUN_DEST}" -maxdepth 1 \( -name "*.html" -o -name "*.htm" \) 2>/dev/null | sort -f | head -n 1)
                if [ -n "${HTML_FILE}" ]; then
                  HTML_BASENAME=$(basename "${HTML_FILE}")
                  # Validate filename contains only safe characters to prevent XSS
                  if [[ "${HTML_BASENAME}" =~ ^[a-zA-Z0-9._\ -]+$ ]]; then
                    echo "::notice::No index.html found in test results. Creating redirect from index.html to ${HTML_BASENAME}"
                    printf '%s\n' \
                      '<!DOCTYPE html>' \
                      '<html>' \
                      '<head>' \
                      '  <meta charset="utf-8">' \
                      "  <meta http-equiv=\"refresh\" content=\"0; url=${HTML_BASENAME}\">" \
                      "  <title>Redirecting to ${HTML_BASENAME}</title>" \
                      '</head>' \
                      '<body>' \
                      "  <p>Redirecting to <a href=\"${HTML_BASENAME}\">${HTML_BASENAME}</a>...</p>" \
                      '</body>' \
                      '</html>' \
                      > "${RUN_DEST}/index.html"
                  else
                    echo "::warning::HTML file '${HTML_BASENAME}' contains unsafe characters; skipping redirect index.html creation"
                  fi
                fi
              fi
            else
              echo "::warning::Test results directory is empty or does not exist: ${GH_PAGES_ACTION_HOME}/${TEST_RESULTS}"
            fi
          fi;
        }
        #-------------------------------------------------------------------
        generate_index_html_func () {
          python3 "${INDEX_SCRIPT_PATH}" --order "${ORDER}"
          echo "Completed index html generation"
        }
        #-------------------------------------------------------------------
        echo "current path: $PWD"
        mkdir -p "./${GH_PAGES}"
        mkdir -p "${GH_PAGES_ACTION_HOME}/${TEST_RESULTS}"
        echo "NEW results history folder ${GH_PAGES}"
        echo "New GH_PAGES folder: ${GH_PAGES}"
        echo "NEW github pages url ${GITHUB_PAGES_WEBSITE_URL}"       
        echo "GH_PAGES=${GH_PAGES}" >> $GITHUB_ENV
        echo "GITHUB_PAGES_WEBSITE_URL=${GITHUB_PAGES_WEBSITE_URL}" >> $GITHUB_ENV
        echo "GITHUB_PAGES_WEBSITE_URL=${GITHUB_PAGES_WEBSITE_URL}" >> $GITHUB_OUTPUT
        #-------------------------------------------------------------------
        echo "LATEST_RUN_GH_PAGES_URL=${GITHUB_PAGES_WEBSITE_URL}/${{ github.run_number }}/index.html" >> $GITHUB_OUTPUT
        # Publish Job Summary
        if [[ "${USE_ACTIONS_SUMMARY}" != 'false' ]]; then
          echo "GH Pages History URL: ${REPORT_URL}" >> $GITHUB_STEP_SUMMARY
          echo "GH Pages Latest Result URL: ${GITHUB_PAGES_WEBSITE_URL}/${{ github.run_number }}/index.html" >> $GITHUB_STEP_SUMMARY
        fi;
        #-------------------------------------------------------------------
        # First Run Delete Function
        cd "./${GH_PAGES}"
        delete_folders_func
        cd "$GH_PAGES_ACTION_HOME"
        #-------------------------------------------------------------------
        # Copy current test-results for staging
        copy_current_results_func
        #-------------------------------------------------------------------   
        # Generate Final FOLDER STRUCTURE at lowest level
        cd "./${GH_PAGES}"
        generate_index_html_func
        cd "$GH_PAGES_ACTION_HOME"
        #-------------------------------------------------------------------   
        # Generate index.html at each level of the directory hierarchy
        # Build path segments: base / subfolder / tool / workflow / env
        INDEX_DIR="${GH_PAGES_ACTION_HOME}/${GH_PAGES_BASE}"
        # Always generate at the base level
        cd "${INDEX_DIR}"
        generate_index_html_func
        cd "$GH_PAGES_ACTION_HOME"
        # Walk through each optional path segment and generate index.html
        for SEGMENT in "${SUBFOLDER}" "${TOOL_NAME}" "${WORKFLOW_NAME}" "${ENV}"; do
          if [[ -n "${SEGMENT}" ]]; then
            INDEX_DIR="${INDEX_DIR}/${SEGMENT}"
            if [[ -d "${INDEX_DIR}" ]]; then
              cd "${INDEX_DIR}"
              generate_index_html_func
              cd "$GH_PAGES_ACTION_HOME"
            fi
          fi
        done
        #-------------------------------------------------------------------
        cd "$GH_PAGES_ACTION_HOME"
        # Manage History and Last History Folders
        # Create History folder just in case if its not present.
        # For Allure Reports it would be present by default
        # For other reports it will not be present
        mkdir -p "./${GH_PAGES}/${GITHUB_RUN_NUM}/history"
        #-------------------------------------------------------------------
        cd "$GH_PAGES_ACTION_HOME"
        cd "./${GH_PAGES}"
        if [ -d last-history ] && [ "$(ls -A ./last-history 2>/dev/null)" ]; then
           #Copy Last History from previous run in to Allure Results Folder for Allure Report Generation
           cp -r ./last-history/. "${GH_PAGES_ACTION_HOME}/${TEST_RESULTS}/history"
        fi;
        #--------------------------------------------------------------------
        # Allure Report Generation
        if [[ "${ALLURE_FLAG}" == 'true' ]]; then
          cd "$GH_PAGES_ACTION_HOME"
          npm -g install allure-commandline
          npx allure --version
          # cd "${GH_PAGES_ACTION_HOME}/${TEST_RESULTS}"
          create_executor_json_func 
          npx allure generate ${TEST_RESULTS} -o allure-report --clean
          # finally copy allure report
          if [ -d allure-report ] && [ "$(ls -A allure-report 2>/dev/null)" ]; then
            cp -r allure-report/. "${GH_PAGES}/${GITHUB_RUN_NUM}"
          else
            echo "::error::Allure report generation failed - allure-report directory is empty or does not exist"
            exit 1
          fi
          # Create Last History Folder if its not present
          mkdir -p "./${GH_PAGES}/last-history"
          # Create History folder in Test Results just in case so next command copy won't fail
          mkdir -p "${GH_PAGES}/${GITHUB_RUN_NUM}/history"
          # Move files from Last History folder to History folder inside the most latest run that is currently being run right now
          # This is to show up history and retires information under Allure Reports
          if [ -d "./${GH_PAGES}/last-history" ]; then
            if [ -d ./allure-report/history ] && [ "$(ls -A ./allure-report/history 2>/dev/null)" ]; then
              cp -r ./allure-report/history/. "./${GH_PAGES}/last-history"
            fi
          else
            mkdir "./${GH_PAGES}/last-history"
            if [ -d ./allure-report/history ] && [ "$(ls -A ./allure-report/history 2>/dev/null)" ]; then
              cp -r ./allure-report/history/. "./${GH_PAGES}/last-history"
            fi
          fi;
        fi;
        #--------------------------------------------------------------------

    - name: Deploy report to Github Pages (Same Repository)
      if: ${{ inputs.external_repository == '' }}
      uses: peaceiris/actions-gh-pages@v4.0.0
      with:
        github_token: ${{ inputs.token }}
        force_orphan: ${{ inputs.force_orphan }}
        publish_branch: ${{ inputs.gh_pages }}
        keep_files: false
        publish_dir: ${{ inputs.subfolder != '' && format('{0}/{1}', inputs.gh_pages, inputs.subfolder) || inputs.gh_pages }}
        destination_dir: ${{ inputs.subfolder }}
        allow_empty_commit: true

    - name: Deploy report to Github Pages (External Repository)
      if: ${{ inputs.external_repository != '' }}
      uses: peaceiris/actions-gh-pages@v4.0.0
      with:
        personal_token: ${{ inputs.token }}
        publish_branch: ${{ inputs.gh_pages }}
        force_orphan: ${{ inputs.force_orphan }}
        publish_dir: ${{ inputs.subfolder != '' && format('{0}/{1}', inputs.gh_pages, inputs.subfolder) || inputs.gh_pages }}
        external_repository: ${{ inputs.external_repository }}
        keep_files: false
        destination_dir: ${{ inputs.subfolder }}
        allow_empty_commit: true

    - name: Configure GitHub Pages site
      shell: bash
      env: 
        GH_TOKEN: ${{ inputs.token }}
        PAGES_REPO: ${{ inputs.external_repository != '' && inputs.external_repository || github.repository }}
        SOURCE_PATH: ${{ inputs.subfolder != '' && format('/{0}', inputs.subfolder) || '/' }}
        GH_PAGES_BRANCH: ${{ inputs.gh_pages }}
        EXTERNAL_REPO: ${{ inputs.external_repository }}
        REPO_OWNER: ${{ github.repository_owner }}
        REPO_NAME: ${{ github.event.repository.name }}
      run: |
        #----------------------------------------------------------
        # GitHub Pages Site Configuration (consolidated)
        #----------------------------------------------------------
        set -e
        IS_EXTERNAL="false"
        if [[ -n "${EXTERNAL_REPO}" ]]; then
          IS_EXTERNAL="true"
          echo "Checking GitHub Pages configuration for external repository..."
        else
          echo "Checking GitHub Pages configuration..."
        fi

        gh api \
          -H "Accept: application/vnd.github+json" \
          -H "X-GitHub-Api-Version: 2022-11-28" \
          "/repos/${PAGES_REPO}/pages" --silent > gh-pages.txt 2>&1 || true;
        
        GH_SITE_MESSAGE=$(cat gh-pages.txt | xargs)
        
        if echo "${GH_SITE_MESSAGE}" | grep -q 'gh: Not Found (HTTP 404)'; then
          # GitHub Pages not configured - try to create it
          echo "::notice::GitHub Pages not yet configured, attempting to enable it via API"
          gh api \
            --method POST \
            -H "Accept: application/vnd.github+json" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            "/repos/${PAGES_REPO}/pages" \
             -f "source[branch]=${GH_PAGES_BRANCH}" -f "source[path]=${SOURCE_PATH}" --silent > gh-pages-site.json 2>&1 || true;
          
          GH_SITE_CREATION_MESSAGE=$(cat gh-pages-site.json | xargs)
          if echo "${GH_SITE_CREATION_MESSAGE}" | grep -q 'gh: Not Found (HTTP 404)'; then
            echo "::warning::API call to create GitHub Pages site failed (404). Please manually enable GitHub Pages in Settings -> Pages."
          elif echo "${GH_SITE_CREATION_MESSAGE}" | grep -q 'gh: Resource not accessible'; then
            echo "::warning::API call to create GitHub Pages site failed (403 - Insufficient permissions)."
            if [[ "${IS_EXTERNAL}" == "true" ]]; then
              echo "::warning::For external repositories, you must use a Personal Access Token (PAT) with 'repo' and 'pages: write' scopes."
              echo '::warning::Please provide: token: ${{ secrets.GH_PAT }} in your workflow file'
            else
              echo "::warning::To fix this, add 'pages: write' permission to your workflow, or manually enable GitHub Pages in Settings -> Pages."
            fi
          else
            echo "::notice::GitHub Pages configured successfully via API"
          fi;
        else
          # GitHub Pages already exists - check its configuration
          echo "GitHub Pages already configured"
          
          # Check the build_type to determine if we should update
          if command -v jq &> /dev/null; then
            BUILD_TYPE=$(jq -r '.build_type // ""' gh-pages.txt 2>/dev/null || echo "")
          else
            BUILD_TYPE=$(awk -F'"' '/"build_type"/ {print $4}' gh-pages.txt 2>/dev/null || echo "")
          fi
          
          echo "Detected deployment method: ${BUILD_TYPE:-unknown}"
          
          if [ "$BUILD_TYPE" = "workflow" ]; then
            echo "::notice::GitHub Pages is using 'GitHub Actions' deployment method"
            echo "::notice::Source branch configuration is not applicable for Actions deployments"
            echo "::notice::Your deployment was successful via peaceiris/actions-gh-pages"
          elif [ "$BUILD_TYPE" = "legacy" ]; then
            echo "Updating GitHub Pages source branch configuration..."
            gh api \
              --method PUT \
              -H "Accept: application/vnd.github+json" \
              -H "X-GitHub-Api-Version: 2022-11-28" \
              "/repos/${PAGES_REPO}/pages" \
               -f "source[branch]=${GH_PAGES_BRANCH}" -f "source[path]=${SOURCE_PATH}" --silent > gh-pages-site.json 2>&1 || true;
            
            GH_SITE_UPDATE_MESSAGE=$(cat gh-pages-site.json | xargs)
            if echo "${GH_SITE_UPDATE_MESSAGE}" | grep -q 'gh: Not Found (HTTP 404)'; then
              echo "::warning::API call to update GitHub Pages site failed (404). The site should still work if already configured."
            elif echo "${GH_SITE_UPDATE_MESSAGE}" | grep -q 'gh: Resource not accessible'; then
              echo "::warning::API call to update GitHub Pages site failed (403 - Insufficient permissions)."
              if [[ "${IS_EXTERNAL}" == "true" ]]; then
                echo "::warning::For external repositories, ensure your PAT has 'repo' and 'pages: write' scopes."
              else
                echo "::warning::To fix this, add 'pages: write' permission to your workflow."
              fi
              echo "::notice::Your deployment was successful, but source branch settings were not updated"
            else
              echo "::notice::GitHub Pages source branch updated successfully"
            fi
          else
            echo "::notice::GitHub Pages deployment method is unknown or not detected"
            echo "::notice::Your content has been deployed successfully via peaceiris/actions-gh-pages"
            echo "::notice::If this is the first deployment, you may need to manually enable GitHub Pages in Settings → Pages"
          fi
        fi;
        
        # Get and display the GitHub Pages URL
        REPORT_URL=$(gh api -H "Accept: application/vnd.github+json" -H "X-GitHub-Api-Version: 2022-11-28" "/repos/${PAGES_REPO}/pages" --jq '.html_url' 2>/dev/null | xargs || echo "")
        # Validate the response is a real URL (not a 403 error JSON body)
        if [[ -n "$REPORT_URL" && "$REPORT_URL" == http* && "$REPORT_URL" != *"Resource not accessible"* ]]; then
          REPORT_URL="${REPORT_URL%/}"
          echo "Your GitHub Pages URL: $REPORT_URL"
        else
          if [[ "${IS_EXTERNAL}" == "true" ]]; then
            EXT_OWNER="${EXTERNAL_REPO%%/*}"
            EXT_NAME="${EXTERNAL_REPO##*/}"
            FALLBACK_URL="https://${EXT_OWNER}.github.io/${EXT_NAME}"
          else
            FALLBACK_URL="https://${REPO_OWNER}.github.io/${REPO_NAME}"
          fi
          echo "::notice::GitHub Pages URL (constructed): ${FALLBACK_URL}"
          echo "::notice::To get the exact URL via API, add 'pages: write' to your workflow permissions block."
        fi
        
        # Clean up temp files
        rm -f gh-pages.txt gh-pages-site.json
