#!/usr/bin/env python3

import argparse
import datetime
import json
import os
import sys
from pathlib import Path
from urllib.parse import quote

try:
    from jinja2 import Environment, FileSystemLoader
except ImportError:
    sys.exit(
        "ERROR: Jinja2 is required.\n"
        "Install it with:  pip install jinja2"
    )

DEFAULT_OUTPUT_FILE = 'index.html'

# Marker embedded in every navigation index.html we generate.
# Its presence tells us the file is ours; absence means it is a user-owned report
# that must never be overwritten.
GENERATED_MARKER = '<!-- html-reporter-github-pages:navigation -->'

# Fingerprints present in pages generated by older versions of this script
# (before the GENERATED_MARKER was introduced).  If any of these are found the
# file is treated as a previously-generated navigation page and is safe to
# overwrite with the new template.
LEGACY_MARKERS = (
    'class="goup"',          # back-to-parent row added by every version
    'html-reporter-github-pages',  # part of the old inline title / comments
    'Test Reports</title>',  # title pattern used in all old versions
)

# Number of bytes read when checking for the generated marker.
MARKER_READ_BYTES = 2048

# Entry name prefixes that are excluded from the listing unless --include-hidden is set.
EXCLUDED_PREFIXES = ('last-history', 'gh-pages', 'favicon.ico', 'docs', 'run-timestamps.json')

# Unicode icons for each entry type used in the HTML listing.
ENTRY_ICONS = {
    'folder':          '\U0001f4c1',  # üìÅ
    'folder-shortcut': '\U0001f4c2',  # üìÇ
    'file':            '\U0001f4c4',  # üìÑ
    'file-shortcut':   '\U0001f517',  # üîó
}


def is_generated_index(index_path):
    """Return True when index_path was written by this script.

    Checks for the current GENERATED_MARKER first, then falls back to
    LEGACY_MARKERS so that navigation pages created by older versions of the
    action (before the marker was introduced) are recognised and upgraded
    rather than wrongly treated as user-owned reports.
    """
    try:
        with open(index_path, 'r', encoding='utf-8', errors='replace') as fh:
            content = fh.read(MARKER_READ_BYTES)
            if GENERATED_MARKER in content:
                return True
            return any(lm in content for lm in LEGACY_MARKERS)
    except OSError:
        return False


def process_dir(top_dir, opts):
    glob_patt = opts.filter or '*'

    path_top_dir = Path(top_dir)

    index_path = Path(path_top_dir, opts.output_file)

    if opts.verbose:
        print(f'Traversing dir {path_top_dir.absolute()}')

    # Safety guard: never overwrite a user-owned index.html.
    # If the file exists and does NOT contain our marker it belongs to the user
    # (e.g. a renamed cucumber.html or any other HTML report).  Skip silently so
    # the report remains intact and the navigation is not clobbered on top of it.
    if index_path.exists() and not opts.force and not is_generated_index(index_path):
        print(f'::notice::Skipping navigation index.html generation in '
              f'{path_top_dir.absolute()} ‚Äî existing index.html is a user report, not a generated navigation file.')
        return

    # Load run-timestamps.json manifest if present; maps run-number ‚Üí ISO timestamp.
    # Written/appended by the action on each run so timestamps survive force-orphan
    # redeployments that otherwise reset all filesystem mtimes.
    run_timestamps: dict = {}
    ts_manifest = path_top_dir / 'run-timestamps.json'
    if ts_manifest.exists():
        try:
            run_timestamps = json.loads(ts_manifest.read_text(encoding='utf-8'))
        except (ValueError, OSError):
            pass

    # sort dirs first
    sorted_entries = sorted(path_top_dir.glob(glob_patt), key=lambda p: (p.is_file(), p.name), reverse=opts.reverse)
    entries: list = []

    for entry in sorted_entries:

        # don't include index.html in the file listing
        if entry.name.lower() == opts.output_file.lower():
            continue

        #  skip .hidden dot files and other known non-report entries unless explicitly requested
        if not opts.include_hidden and (
            entry.name.startswith('.') or entry.name.startswith(EXCLUDED_PREFIXES)
        ):
            continue

        if entry.is_dir() and opts.recursive:
            process_dir(entry, opts)

        # From Python 3.6, os.access() accepts path-like objects
        if (not entry.is_symlink()) and not os.access(str(entry), os.R_OK):
            print(f"*** WARNING *** entry {entry.absolute()} is not readable! SKIPPING!")
            continue
        if opts.verbose:
            print(f'{entry.absolute()}')

        size_bytes = -1
        size_pretty = None
        last_modified = None
        last_modified_human = ''
        last_modified_iso = ''
        try:
            if entry.is_file():
                size_bytes = entry.stat().st_size
                size_pretty = pretty_size(size_bytes)
            elif entry.is_dir() and not entry.is_symlink():
                size_bytes = dir_size(entry)
                size_pretty = pretty_size(size_bytes)

            if entry.is_dir() or entry.is_file():
                # Resolve timestamp with a three-level priority:
                #  1. run-timestamps.json manifest (shared, appended every run)
                #  2. per-folder .created_at sentinel (written on first deploy)
                #  3. stat().st_mtime fallback (unreliable after force-orphan)
                created_at_file = entry / '.created_at'
                ts_str = None
                if entry.is_dir():
                    ts_str = run_timestamps.get(entry.name)
                if not ts_str and entry.is_dir() and created_at_file.exists():
                    try:
                        ts_str = created_at_file.read_text(encoding='utf-8').strip()
                    except (OSError, UnicodeDecodeError):
                        pass
                if ts_str:
                    try:
                        # Normalise 'Z' suffix ‚Üí '+00:00' so fromisoformat works on
                        # Python <3.11 and JS new Date() correctly treats value as UTC.
                        ts_norm = ts_str.replace('Z', '+00:00')
                        last_modified = datetime.datetime.fromisoformat(ts_norm).replace(microsecond=0)
                    except ValueError:
                        last_modified = datetime.datetime.fromtimestamp(
                            entry.stat().st_mtime, tz=datetime.timezone.utc).replace(microsecond=0)
                else:
                    last_modified = datetime.datetime.fromtimestamp(
                        entry.stat().st_mtime, tz=datetime.timezone.utc).replace(microsecond=0)
                last_modified_iso = last_modified.isoformat()
                last_modified_human = last_modified.strftime("%c")

        except Exception as e:
            print('ERROR accessing file name:', e, entry)
            continue

        entry_path = str(entry.name)

        if entry.is_dir() and not entry.is_symlink():
            entry_type = 'folder'
            if os.name not in ('nt',):
                # append trailing slash to dirs, unless it's windows
                entry_path = os.path.join(entry.name, '')

        elif entry.is_dir() and entry.is_symlink():
            entry_type = 'folder-shortcut'
            print('dir-symlink', entry.absolute())

        elif entry.is_file() and entry.is_symlink():
            entry_type = 'file-shortcut'
            print('file-symlink', entry.absolute())

        else:
            entry_type = 'file'

        entries.append({
            'href': quote(entry_path),
            'name': entry.name,
            'icon': ENTRY_ICONS.get(entry_type, 'üìÑ'),
            'size_bytes': size_bytes,
            'size_pretty': size_pretty,
            'last_modified_iso': last_modified_iso,
            'last_modified_human': last_modified_human,
        })

    _render_index(index_path, path_top_dir.name, entries)


def _render_index(index_path, folder_name, entries):
    """Render the Jinja2 template and write the index file."""
    template_dir = Path(__file__).parent
    env = Environment(
        loader=FileSystemLoader(str(template_dir)),
        autoescape=True,
        trim_blocks=True,
        lstrip_blocks=True,
        keep_trailing_newline=True,
    )
    template = env.get_template('index.html.j2')
    html = template.render(folder_name=folder_name, entries=entries)
    try:
        index_path.write_text(html, encoding='utf-8')
    except OSError as e:
        print('cannot create file %s %s' % (index_path, e))


# bytes pretty-printing
UNITS_MAPPING = [
    (1024 ** 5, ' PB'),
    (1024 ** 4, ' TB'),
    (1024 ** 3, ' GB'),
    (1024 ** 2, ' MB'),
    (1024 ** 1, ' KB'),
    (1024 ** 0, (' byte', ' bytes')),
]


def dir_size(path):
    """Return total byte size of all files inside *path* recursively."""
    total = 0
    try:
        for p in Path(path).rglob('*'):
            if p.is_file() and not p.is_symlink():
                try:
                    total += p.stat().st_size
                except OSError:
                    pass
    except OSError:
        pass
    return total


def pretty_size(bytes, units=UNITS_MAPPING):
    """Human-readable file sizes.

    ripped from https://pypi.python.org/pypi/hurry.filesize/
    """
    for factor, suffix in units:
        if bytes >= factor:
            break
    amount = int(bytes / factor)

    if isinstance(suffix, tuple):
        singular, multiple = suffix
        if amount == 1:
            suffix = singular
        else:
            suffix = multiple
    return str(amount) + suffix


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='''DESCRIPTION:
    Generate directory index files (recursive is OFF by default).
    Start from current dir or from folder passed as first positional argument.
    Optionally filter by file types with --filter "*.py". ''')

    parser.add_argument('top_dir',
                        nargs='?',
                        action='store',
                        help='top folder from which to start generating indexes, '
                             'use current folder if not specified',
                        default=os.getcwd())

    parser.add_argument('--filter', '-f',
                        help='only include files matching glob',
                        required=False)

    parser.add_argument('--output-file', '-o',
                        metavar='filename',
                        default=DEFAULT_OUTPUT_FILE,
                        help=f'Custom output file, by default "{DEFAULT_OUTPUT_FILE}"')

    parser.add_argument('--recursive', '-r',
                        action='store_true',
                        help="recursively process nested dirs (FALSE by default)",
                        required=False)

    parser.add_argument('--include-hidden', '-i',
                        action='store_true',
                        help="include dot hidden files (FALSE by default)",
                        required=False)

    parser.add_argument('--verbose', '-v',
                        action='store_true',
                        help='***WARNING: can take longer time with complex file tree structures on slow terminals***'
                             ' verbosely list every processed file',
                        required=False)

    parser.add_argument('--order',
                        choices=['ascending', 'descending'],
                        default='ascending',
                        help='Sort order for directory entries (ascending by default, use descending for reverse chronological order)')

    parser.add_argument('--force', action='store_true', default=False,
                        help='Overwrite existing index.html even if it was not generated by this script')

    config = parser.parse_args(sys.argv[1:])
    # Set reverse flag based on order
    config.reverse = (config.order == 'descending')
    process_dir(config.top_dir, config)